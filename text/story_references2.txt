         1         2         3         4         5         6         7         8
12345678901234567890123456789012345678901234567890123456789012345678901234567890

jani.hautamaki@hotmail.com 
November 2012

This is a message that I posted to Google Groups on 21.10.2012. It is 
a continuation to the three stories of the previous message posted on
the same date. The most important observatinos here are related to the types
of references that are going to be needed at some point. Also, there is
an _absolutely fantastic_ demonstration what is the different between
contentual equivalence and "semantic" equivalence: even thugh the contents
of an XML element are identical, their "meaning" might depend CRITICALLY
on the surrounding sibling elements. The dependencies of the meaning
are not formalized into XML references, and thus it is possible that
a very significant change in the meaning does not neccessarily imply 
a change in contents.

===[ 3 stories about referencing: observations ]===============================


Regarding the stories, the following situations can be recognized:

a) References relate to an actual configuration at a specific
point in time.

b) References do not unambiguously identify their parent elements.
(This is a logical consequence of the property that references
are insensitive to changes in their parent elements).

c) Some set of references are supposed to identify
the same parent element.

d) Some set of references are supposed to be references
into a single set of unique @id attributes.
  
e) The interpretation of referenced contents depend on
the knowledge of the context.


-------------

Some comments.

Migration is here understood as a process of replacing each
reference to an object with a reference to the latest revision
of the object in the same "line of evolution", which may include
renaming @id attributes of an element. Such a process can be
automated with revisioning data.



a) References relate to an actual configuration at a specific
point in time.

- If migration represents a transition from one temporal state to
another, then migrating the reference tied to an object in
a particular point in time may turn the referencing data to
make incorrect statements. If the migration represents
a transition from one state to another at the same point in
time (eg. fixing typos in the description of the left upper limb)
the migration would seem valid.

- After the anchor tattoo the reference could be migrated if there
is a new observation. However, after the ring the reference cannot
be migrated, since it would make a statement contradicting the
referenced data.




b) References do not unambiguously identify their parent elements.
(This is a logical consequence of the property that references
are insensitive to changes in their parent elements).

- An information about the referenced object might be expressed
in such a way that it employs a tacit assumption of a parent
element. One could attempt to use the reference or the referenced
object to attempt identifying the parent object. It is not
possible if the reference implies multiple possible parents.



c) Some set of references are supposed to identify
the same parent element.

- This observation is simply the statement of the tacitly assumed
property that some set of references should have. The problems
start to appear when one combines both b) and c). That is, one
cannot identify the parent with the reference unambiguously,
but one requires the references to identify objects which
have the same parent.

- For instance, the expression of information that a lower limb
belongs to a particular person, or more precisely, a person with
name X has a lower left limb which looks like Y, it is assumed
that X and Y will indirectly identify the same parent object,
namely the same person. But if context-insensitive references are
used, then there is no guarantee that the referenced objects
belong (the owner relationship again..) to the same parent object.
 
- In the Hamlet story this applies to the advertisement, it is
implicitly assumed that the role descriptions are related to
roles of the same play. It wouldn't make sense to have an
advertisement of a play in which the description of roles
are from two different plays.

- In the third story, this applies to the coding of the open-ended
occupation questionnaire in the third story. The coding won't
seem to make sense if two different revisions of a classification
is used within the encoding of the same respodent.



d) Some set of references are supposed to be references
into a single set of unique @id attributes.

- This probably applies to the occupation classification case.
The classification is modeled in such a way that each <class>
child elements @id is considered to identify a different occupation
class with the actual classification code somehow matching the @id
of the element. It would mean, that two different revisions of
same @id within a single classification scheme wouldn't probably
be considered making sense, because one would like the @id
"physicist" to refer just to a single occupation class (the physicist
occupation) within a particular classification scheme (eg. ISCO of
year XYZ) insted of referring to two or more possible occupation
classes (the earlier revisions of the physicist occupation which
are available, eg. for historic interest, in the current document
too).

- In the classification example, then, it would appear that
the modeling is done in such a way that additional requiremenets
for values of @id attributes are imposed tacitly.

- I don't know could one think about the occupation classes
in the same way as the person/limb example that what is actually
wanted is a reference to an object assuming some particular role
(eg. the object assuming the role of "physicist" occupation class
in the given classification). A kind of indirection.

- Just a remark that this is not DDI. Two different revisions
of the same object within the same parent object were allowed.
In fact, multiple copies of an element with a particular
(@id, @rev) are allowed. That is, the "same element" can appear
in multiple places. This gives a possibility to use content
of an <upperlimb> or <lowerlimb> determined by a single (@id, @rev)
to specify both limbs, producing in practice re-use of a kind.
For instance, re-using a "no distinctive marks" element for both
limbs. This belongs more the other subject I was planning to
write about, maybe some other time...




e) The interpretation of referenced contents depend on
the knowledge of the context.

- This is a specific comment to the "residue code" with @id="other"
in the occupation classification example. The interpretation of
the element's contents is tightly coupled to the whole classification.

- The relationship can be expressed with mathematical rigor. One can
consider each classification code to be a proposition P(x) about some
object x. For instance, the programmer's occupation class would
correspond to a proposition P(x) = "x is a programmer" for any objet
x in some universe. Making each class into a similar proposition, one can
express the "other" code in this case to be:

OTHER_ORIG(x) <=> not(A(x) or B(x) or C(x))

- When an occupation class is added, but the XML expression of
the residue code is left untouched, the residue code of the classification's
new scheme would be logically equal to:

OTHER_NEW(x) <=> not(A(x) or (B(x) or C(x) or D(x))

- The important realization is that the truth of OTHER_ORIG(x)
does not imply the truth of OTHER_NEW(x), because the truth of D(x)
is not known from the truth OTHER_ORIG(x).

- In the XML model, however, the logical propositions OTHER_ORIG(x)
and OTHER_NEW(x) have identical @id and @rev attribute values, and
are not distinguishable. From a reference ref_id="other:1" it is not
possible to deduce which proposition is meant.

- Also, even if the logical proposition OTHER_ORIG(x) and OTHER_NEW(x)
would have different revision numbers, migration (in the sense
defined earlier) can't be carried out, because the truth of
OTHER_ORIG(x) does not imply the truth of OTHER_NEW(x) in all cases.
The data must be reconsidered / recoded / re-evaluated before
migration.

-------------

This is all I have for now. I hope the text provides new landscapes
to the entire subject. I was planning to go at two different
directions at the same time. One direction was this, and the other
direction was about taking the first steps in the proposed road map
to see whether it might lead so something.

These are somewhat complementary directions, because the first
direction (this message) is about arguing that these kinds of 2-tuple
references will identify the elements properly, just the contents
of elements and nothing more (which is sometimes exactly the problem).
If it is not enough, then it should be considered that maybe
the problem is caused by some additional requirements on the references
which were not recognized. The other direction is to attempt to show
how utilizing a file-level revisioning might be actually employed to
produce an element-wise revisioning in practice.

