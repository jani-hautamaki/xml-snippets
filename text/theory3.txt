         1         2         3         4         5         6         7         8
12345678901234567890123456789012345678901234567890123456789012345678901234567890

jani.hautamaki@hotmail.com 
December 2012

====[ reference migration ]=====================================================


This requires an algorithm which traverses the graph in a certain way _prior_
to ingesting the individual XML elements.


====[ access control ]==========================================================


This can be implemented pretty nicely in conjunction with the denormalization:
each pruning point (an xidentified element) may contain an access restriction,
and if the caller does not have required access level, the denormalization
does not occur further down. 

When thinking about access control in such a way, one is tempted to think that
maybe the access restriction, eg. "required security level" (which is 
an integer) is a property that travels (or is inherited) down to children on 
the XML tree unless there is a newer restriction present. However, a short 
thought experiment shows that this is problematic, since xidentified XML 
elements do not have designated parent elements, and therefore inheriting 
_any_ information down to children causes that information to be ambiguous.

This idea contains some deep wisdom in it. It certainly deserves elaboration.
The chosen equivalence relationship guarantees some invariants for 
an identified XML element. The equivalence relationship chosen in this 
particular implementation makes all the contents of an XML element into
invariants. The relationship does not take a stand about anything which
exists outside the XML element. 

Therefore, any data that is inheritend from parent elements is not guaranteed,
by the equivalence relationship to stay invariant in all instances of a given
id. It would be desirable, of course, if there was a mechanism to guarantee 
some additional invariants to an XML element besides what is asserted by 
the equivalence relationship. Even if some XML elements were used always
as children of some specific inherited data... That is, even if the data 
inherited to an XML element were consistent throughout the data store,
it would still be problematic, because the data couldn't be stored into the
element itself.

If such data is really required to be inherited, then the inheritance must 
be implemented as a preprocessor to the XML data which concretely sets 
the inherited attributes to each child element. This would force consistency,
but it would also require that the attributes in the payload would have to
be divided into two classes: inherited and local.

I guess the primary reason for such an inheritance feature is to avoid 
repeating same information manually. That is, the inheritance works as
automation for copy-pasting something into children.


